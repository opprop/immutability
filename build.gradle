plugins {
    id 'org.ajoberstar.grgit' version '3.1.1' apply false
}

import org.ajoberstar.grgit.Grgit

apply plugin: 'java'

ext {
    assert JavaVersion.current() == JavaVersion.VERSION_1_8: "Set JAVA_HOME to JDK 8. Current version is ${JavaVersion.current()}"
    jsr308 = file(new File("..")).absolutePath
    cfPath = "${jsr308}/checker-framework"
    cfiPath = "${jsr308}/checker-framework-inference"
    afu = "${jsr308}/annotation-tools/annotation-file-utilities"
    picoPath = "${jsr308}/immutability"
}

println '==================================='
println '            PICO Checker           '
println '==================================='
println ''
println '-------------------------------'
println 'Important Environment Variables'
println '-------------------------------'
println 'JSR308: ' + jsr308
println 'CF:     ' + cfPath
println 'CFI:    ' + cfiPath
println 'picoPath:' + picoPath

repositories {
    mavenCentral()
}

dependencies {
    compile fileTree(dir: "${cfPath}/checker/dist", include: "checker.jar")
    compile fileTree(dir: "${cfiPath}/dist", include: "checker-framework-inference.jar")
    // sat4j solver dependency
    compile 'org.ow2.sat4j:org.ow2.sat4j.core:2.3.4'
    compile 'org.ow2.sat4j:org.ow2.sat4j.maxsat:2.3.4'
    // The production code uses the SLF4J logging API at compile time
    compile 'org.slf4j:slf4j-api:1.7.13'
    // CF test lib dependency
    testCompile fileTree(dir: "${cfPath}/framework-test/build/libs", include: "framework-test-*.jar")
    testCompile 'junit:junit:4.12'
}

sourceSets {
    main {
        java {
            srcDirs = ["src/main/java"]
        }

        resources {
            srcDirs = ["src/main/java"]
            exclude "**/*.java"
        }
    }

    test {
        java {
            // TODO: we shouldn't need source level dependency on CFITest
            srcDirs = ["src/test/java", "${cfiPath}/tests/checkers/inference/test"]
        }
    }
}

compileJava {
    options.compilerArgs = [
            '-implicit:class',
            '-Awarns',
            '-Xmaxwarns', '10000',
    ]
}

afterEvaluate {
    // Create a task for each JUnit test class whose name is the same as the JUnit class name.
    sourceSets.test.allJava.filter { it.path.contains("${picoPath}/src/test/java") }.forEach { file ->
        String junitClassName = file.name.replaceAll(".java", "")
        String testName = junitClassName.replaceAll("Test", "")
        tasks.create(name: "${junitClassName}", type: Test) {
            description "Run ${testName} tests."
            include "**/${name}.class"
        }
    }

    // Configure JUnit tests
    tasks.withType(Test) {
        group 'Verification'

        systemProperties 'path.afu.scripts': "${afu}/scripts",
                'path.inference.script': "${cfiPath}/scripts/inference",
                JDK_JAR: "${cfPath}/checker/dist/jdk8.jar"

        environment "external_checker_classpath", "${picoPath}/build/classes/java/main:${picoPath}/build/resources/main"

        jvmArgs "-Xbootclasspath/p:${cfiPath}/dist/javac.jar"

        testLogging {
            // Always run the tests
            outputs.upToDateWhen { false }
            // The following prints out each time a test is passed.
            events "passed", "skipped", "failed", "standardOut", "standardError"

            // Show the found unexpected diagnostics and expected diagnostics not found.
            exceptionFormat "full"
            showExceptions true
            showCauses true
            showStackTraces true
            showStandardStreams true
        }

        // After each test, print a summary.
        afterSuite { desc, result ->
            if (desc.getClassName() != null) {
                long mils = result.getEndTime() - result.getStartTime()
                double seconds = mils / 1000.0

                println "Testsuite: ${desc.getClassName()}\n" +
                        "Tests run: ${result.testCount}, " +
                        "Failures: ${result.failedTestCount}, " +
                        "Skipped: ${result.skippedTestCount}, " +
                        "Time elapsed: ${seconds} sec\n"
            }
        }
    }
}

clean {
    delete "build",
        "testdata",
        "annotated",
        "default.jaif",
        fileTree("testinput") {include "**/*.class"}
}

/* Configuration for formatting */
/* Copy from https://github.com/randoop/randoop/blob/master/build.gradle */
task getCodeFormatScripts {
    description "Obtain the run-google-java-format scripts"
    doLast {
        if (! new File("$projectDir/build/utils/.run-google-java-format").exists()) {
            Grgit.clone(dir: "$projectDir/build/utils/.run-google-java-format", uri: 'https://github.com/plume-lib/run-google-java-format.git')
        } else {
            def rgjfGit = Grgit.open(dir: "$projectDir/build/utils/.run-google-java-format")
            rgjfGit.pull()
        }
    }
}

task pythonIsInstalled(type: Exec) {
    description "Check that the python executable is installed."
    executable = "python"
    args "--version"
}

task checkFormat(type: Exec, dependsOn: [getCodeFormatScripts, pythonIsInstalled], group: 'Formatting') {
    description "Check whether the Java source code is properly formatted"
    def javaFiles = fileTree("$projectDir").matching{
        include "**/*.java" exclude "testinput/**" exclude "testdata/**" exclude "build/**"
    } as List
    def pythonArgs = javaFiles.clone()
    pythonArgs.add(0, "$projectDir/build/utils/.run-google-java-format/check-google-java-format.py")
    pythonArgs.add(1, "--aosp") // 4 space indentation

    commandLine "python"
    args pythonArgs
    ignoreExitValue true

    doLast {
        if (execResult.exitValue != 0) {
            throw new GradleException("Found improper formatting, try running:  ./gradlew reformat")
        }
    }
}

task reformat(type: Exec, dependsOn: [getCodeFormatScripts, pythonIsInstalled], group: 'Formatting') {
    description "Format the Java source code according to the Google Java Format style"
    def javaFiles = fileTree("$projectDir").matching{
        include "**/*.java" exclude "testinput/**" exclude "testdata/**" exclude "build/**"
    } as List
    def pythonArgs = javaFiles.clone()
    pythonArgs.add(0, "$projectDir/build/utils/.run-google-java-format/run-google-java-format.py")
    pythonArgs.add(1, "--aosp") // 4 space indentation

    commandLine "python"
    args pythonArgs
}

task installGitHooks(type: Copy) {
    group=null
    description "Installs git hooks for pre-commit"
    from 'scripts/'
    into '.git/hooks'
}

/* Always run this task */
gradle.startParameter.taskNames = [":installGitHooks"] + gradle.startParameter.taskNames
