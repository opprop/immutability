import qual.Mutable;
import qual.Immutable;
import qual.ReceiverDependentMutable;
import qual.Readonly;
import qual.ObjectIdentityMethod;
import java.util.Collection;

package java.lang;

@ReceiverDependentMutable
class Object {
  @ReceiverDependentMutable Object();
  Class<?> getClass(@Readonly Object this);
  String toString(@Readonly Object this);
  int hashCode(@Readonly Object this);
  boolean equals(@Readonly Object this, @Readonly Object var1);
  @ReceiverDependentMutable Object clone(@ReceiverDependentMutable Object this);
  @ObjectIdentityMethod
  final native Class<?> getClass();
}

class String {
  int length(@Immutable String this);
  char charAt(@Immutable String this, int var1);
  String replace(@Readonly CharSequence target, @Readonly CharSequence replacement);
  boolean contains(@Readonly CharSequence s);
  String substring(@Immutable String this, int var1);
  String substring(@Immutable String this, int var1, int var2);
  String toString(@Immutable String this);
  boolean equals(@Immutable Object var1);
  static String valueOf(@Readonly Object var0);
  static String format(String var0, @Readonly Object @Readonly ... var1);
  static String format(@Readonly Locale l, String format, @Readonly Object @Readonly ... var1);
}

class StringBuilder {
  StringBuilder append(@Readonly Object var1);
}

class StringBuffer {
  int length(@Readonly StringBuffer this);
  int capacity(@Readonly StringBuffer this);
  StringBuffer append(@Readonly Object obj);
  String substring(@Readonly StringBuffer this, int start);
  CharSequence subSequence(@Readonly StringBuffer this, int start, int end);
  String substring(@Readonly StringBuffer this, int start, int end);
  int indexOf(@Readonly StringBuffer this, String str);
  int indexOf(@Readonly StringBuffer this, String str, int fromIndex);
  int lastIndexOf(@Readonly StringBuffer this, String str);
  int lastIndexOf(@Readonly StringBuffer this, String str, int fromIndex);
}

@ReceiverDependentMutable
class Throwable {
  String getMessage(@ReceiverDependentMutable Throwable this);
  String getLocalizedMessage(@ReceiverDependentMutable Throwable this);
  Throwable getCause(@ReceiverDependentMutable Throwable this);
  void printStackTrace(@ReceiverDependentMutable Throwable this);
  void printStackTrace(@ReceiverDependentMutable Throwable this, PrintStream var1);
  void printStackTrace(@ReceiverDependentMutable Throwable this, Throwable.PrintStreamOrWriter var1);
}

@ReceiverDependentMutable
interface CharSequence {
  int length(@Readonly CharSequence this);
  char charAt(@Readonly CharSequence this, int index);
  CharSequence subSequence(@Readonly CharSequence this, int start, int end);
  public default IntStream chars(@Readonly CharSequence this);
  public default IntStream codePoints(@Readonly CharSequence this);
}

@ReceiverDependentMutable
class RuntimeException {
  @ReceiverDependentMutable RuntimeException(@Readonly Throwable var1);
  @ReceiverDependentMutable RuntimeException(String var1, @Readonly Throwable var2, boolean var3, boolean var4);
}

@ReceiverDependentMutable
class IndexOutOfBoundsException {}

@Immutable
class Enum<E extends @Immutable Enum<E>> {
  @Immutable Enum(String name, int ordinal);
  int ordinal(@Immutable Enum<E> this);
}

@ReceiverDependentMutable
interface Cloneable {}

@ReceiverDependentMutable
interface Comparable<T> {}

package java.util;

@ReceiverDependentMutable
class Properties {
  @Readonly Object put(@Immutable Object key, @Readonly Object value);
}

interface Iterator<E extends @Readonly Object> {}

@ReceiverDependentMutable
class Date {
  @ReceiverDependentMutable Date();
  @ReceiverDependentMutable Date(long var1);
  int getHours(@ReceiverDependentMutable Date this);
}

@ReceiverDependentMutable
interface Collection<E> {
  boolean contains(@Readonly Collection<E> this, @Readonly Object o);
}

@ReceiverDependentMutable
public abstract class AbstractCollection<E> implements Collection<E> {
    public abstract int size(@Readonly AbstractCollection this);
}

@ReceiverDependentMutable
class ArrayList<E> {
  @ReceiverDependentMutable ArrayList();
  @ReceiverDependentMutable ArrayList(@Readonly Collection<? extends E> var1);
  boolean add(E var1);
  boolean addAll(@Readonly Collection<? extends E> c);
  E get(@Readonly ArrayList<E> this, int index);
  int size(@Readonly ArrayList<E> this);
  boolean isEmpty(@Readonly ArrayList<E> this);
  boolean contains(@Readonly ArrayList<E> this, @Readonly Object o);
  int indexOf(@Readonly ArrayList<E> this, @Readonly Object o);
  int lastIndexOf(@Readonly ArrayList<E> this, @Readonly Object o);
  Iterator<E> iterator(@Readonly ArrayList<E> this);
}

@ReceiverDependentMutable
interface List<E> {
  int size(@Readonly List<E> this);
  boolean isEmpty(@Readonly List<E> this);
  Iterator<E> iterator(@Readonly List<E> this);
  Object[] toArray(@Readonly List<E> this);
  <T> T[] toArray(@Readonly List<E> this, T[] a);
  boolean containsAll(@Readonly List<E> this, @Readonly Collection<?> c);
  E get(@Readonly List<E> this, int index);
  boolean contains(@Readonly List<E> this, @Readonly Object o);
  boolean remove(@Readonly Object o);
  boolean removeAll(@Readonly Collection<?> c);
  boolean addAll(@Readonly Collection<? extends E> c);
  boolean addAll(int index, @Readonly Collection<? extends E> c);
  int indexOf(@Readonly List<E> this, @Readonly Object o);
  int lastIndexOf(@Readonly List<E> this, @Readonly Object o);
  ListIterator<E> listIterator(@Readonly List<E> this);
  ListIterator<E> listIterator(@Readonly List<E> this, int index);
}

@ReceiverDependentMutable
class AbstractList<E> {
  @ReceiverDependentMutable AbstractList();
  void add(@Mutable AbstractList<E> this, int var1, E var2);
}

@ReceiverDependentMutable
interface Set<E> {
  int size(@Readonly Set<E> this);
  boolean isEmpty(@Readonly Set<E> this);
  boolean contains(@Readonly Set<E> this, @Readonly Object var1);
  Iterator<E> iterator(@Readonly Set<E> this);
  Object[] toArray(@Readonly Set<E> this);
  <T> T[] toArray(@Readonly Set<E> this, T[] a);
  boolean containsAll(@Readonly Set<E> this, @Readonly Collection<?> c);
  boolean remove(@Readonly Object o);
  boolean addAll(@Readonly Collection<? extends E> c);
}

@ReceiverDependentMutable
class HashSet<E> {
  @ReceiverDependentMutable HashSet();
  @ReceiverDependentMutable HashSet(@Readonly Collection<? extends E> var1);
  boolean contains(@Readonly HashSet<E> this, @Readonly Object var1);
  boolean remove(@Readonly Object var1);
}

@ReceiverDependentMutable
interface Map<K extends @Immutable Object, V> {
  int size(@Readonly Map<K, V> this);
  boolean isEmpty(@Readonly Map<K, V> this);
  boolean containsKey(@Readonly Map<K, V> this, @Readonly Object var1);
  boolean containsValue(@Readonly Map<K, V> this, @Readonly Object value);
  V get(@Readonly Map<K, V> this, @Readonly Object var1);
  V remove(@Readonly Object key);
  void putAll(@Readonly Map<? extends K, ? extends V> m);
  Set<K> keySet(@Readonly Map<K, V> this);
  Collection<V> values(@Readonly Map<K, V> this);
  Set<Map.Entry<K, V>> entrySet(@Readonly Map<K, V> this);
}

@ReceiverDependentMutable
class HashMap<K extends @Immutable Object, V> {
  @ReceiverDependentMutable HashMap();
  @ReceiverDependentMutable HashMap(@Readonly Map<? extends K, ? extends V> var1);
  V get(@Readonly HashMap<K, V> this, @Readonly Object key);
  boolean containsKey(@Readonly HashMap<K, V> this, @Readonly Object key);
  boolean containsValue(@Readonly HashMap<K, V> this, @Readonly Object value);
}

class Collections {
  static <T> @Immutable List<T> unmodifiableList(@Readonly List<? extends T> list);
}

class StringJoiner {
  StringJoiner(@Readonly CharSequence delimiter);
  StringJoiner(@Readonly CharSequence delimiter, @Readonly CharSequence prefix, @Readonly CharSequence suffix);
  StringJoiner add(@Readonly CharSequence newElement);
}

class Arrays {
  static <T> @Immutable List<T> asList(T @Readonly ... var0);
  static String toString(int @Readonly [] var0);
  static boolean equals(float @Readonly [] var0, float @Readonly [] var1);
  static boolean equals(double @Readonly [] var0, double @Readonly [] var1);
  static <T> T[] copyOf(T @Readonly [] original, int newLength);
}

class Objects {
  static int hashCode(@Readonly Object o);
  static boolean equals(@Readonly Object a, @Readonly Object b);
}

@ReceiverDependentMutable
class Stack<E> {
  E peek(@ReceiverDependentMutable Stack<E> this);
  boolean empty(@ReceiverDependentMutable Stack<E> this);
}

@ReceiverDependentMutable
class Vector<E> {
  boolean isEmpty(@Readonly Vector<E> this);
}

@ReceiverDependentMutable
class Hashtable<K extends @Immutable Object,V> {
  V get(@Readonly Hashtable<K,V> this, @Readonly Object key);
  boolean containsKey(@Readonly Hashtable<K,V> this, @Readonly Object key);
}

package java.util.logging;
class Logger {
  void log(@Readonly Level level, String msg, @Readonly Throwable thrown);
}

package java.util.regex;
class Pattern {
  Matcher matcher(@Readonly CharSequence input);
  static boolean matches(String regex, @Readonly CharSequence input);
  String[] split(@Readonly CharSequence input, int limit);
  String[] split(@Readonly CharSequence input);
  static final int countChars(@Readonly CharSequence seq, int index, int lengthInCodePoints);
  static final int countCodePoints(@Readonly CharSequence seq);
}

package java.io;

@ReceiverDependentMutable
class PrintStream {
  void print(@ReceiverDependentMutable PrintStream this, String var1);
  PrintStream printf(@ReceiverDependentMutable PrintStream this, String var1, @Readonly Object @Readonly ... var2);
  PrintStream format(String format, @Readonly Object @Readonly ... args);
}

@ReceiverDependentMutable
class PrintWriter {
  PrintWriter printf(@ReceiverDependentMutable PrintWriter this, String var1, @Readonly Object @Readonly ... var2);
}

@ReceiverDependentMutable
class File {
  @ReceiverDependentMutable File(@Readonly File parent, String child);
  boolean isFile(@Readonly File this);
  String[] list(@Readonly File this);
  String getPath(@Readonly File this);
  long length(@Readonly File this);
  String getName(@Readonly File this);
}

@ReceiverDependentMutable
class FileInputStream {
  @ReceiverDependentMutable FileInputStream(@Readonly File file);
}

class ObjectOutputStream {
  void writeObject(@Readonly Object obj);
}

@ReceiverDependentMutable
interface Serializable {}

package java.awt;

@ReceiverDependentMutable
class Container {
  void add(@Readonly Component comp, @Readonly Object constraints);
}
